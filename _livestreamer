#compdef livestreamer

# wrongparse twitch's json api
# returns stream_names and stream_descrs (non-associative) arrays
# see http://www.twitch.tv/docs/api/team.html
_twitch_team_live () {
    local tmp chan
    # tmp="$(curl -s http://api.twitch.tv/api/team/$1/live_channels.json)"
    # yeah test data
    tmp="$(<testdata)"
    if [[ $tmp != '{"channels":[{"channel":{'* ]]; then
        return 1
    fi
    tmp=${${tmp#'{"channels":[{"channel":{'}%'}}]}'}
    # split channel info
    tmp=( ${(ps.\}\},\{\"channel\":\{.)tmp} )
    # got at least one?
    (( $#tmp )) || return 1

    local viewmin maxstreams
    zstyle -s ":completion:${curcontext}:twitch" viewmin viewmin || viewmin=50
    zstyle -s ":completion:${curcontext}:twitch" maxstreams maxstreams || maxstreams=20

    # associative arrays are not ordered, so we use regular ones with synced indices here.
    stream_names=( )
    stream_descrs=( )
    typeset -A att
    # generate names and descriptions
    for chan in ${${tmp#\"}%\"}; do
        att=( )
        # parse al of those
        for p in ${(ps:,\":)chan}; do
            # nvm the typeset, unbalanced \" in subscripts are weird :)
            typeset "att[${p%%\"*}]"=${${${p#*\":}#\"}%\"}
        done
        # look at this if we have mandatory fields
        if (( $+att[name] && $+att[display_name] && $+att[current_viewers] )); then

            # break if we are below the desired min viewer count
            (( $att[current_viewers] >= viewmin )) || break
            # check if we are at the maximum
            (( $#stream_names <= maxstreams )) || break

            # ok, add with description
            stream_names+=( $att[name] )
            stream_descrs+=( "${(l:5:: :)att[current_viewers]}  ${(r:15:: :)att[display_name]} $att[title]" )

        fi
    done
}

_livestreamer_twitch.tv () {

    local ret=1
    local -a teams tmp stream_names stream_descrs

    _tags teamstreams
    while _tags; do
        if _requested subscribedstreams; then
            ret=1
        fi
        if _requested teamstreams; then
            teams=( srl )
            for team in $teams; do
                _twitch_team_live $team
                _all_labels -V teamstreams expl "Team '$team'" \
                    compadd -d stream_descrs -a stream_names && ret=0
            done
        fi
        (( ret )) || break

    done

}

_livestreamer_urls () {

    # ALRIGHT THIS IS IT
    local -a expl
    local ret=1 service

    # complete protocol
    if ! compset -P '(#b)([-+.a-z0-9]#)://'; then
        compstate[to_end]=''
        _wanted prefixes expl 'url prefix' \
            compadd -S '' "$expl[@]" 'http://' && return 0
        return 1
    fi
    # we could capture the scheme here, but we don't actually care
    # scheme="$match[1]"

    typeset -a plugins
    plugins=( justin.tv twitch.tv ustream.net )

    if ! compset -P '(#b)([-+.a-zA-Z0-9]#)/'; then
        _wanted prefixes expl 'streaming service' \
            compadd -S '/' "$expl[@]" -a plugins && return 0
        return 1
    fi

    # capture the service
    service=$match[1]

    if (( $+functions[_livestreamer_$service] )); then
        _livestreamer_$service
    else
        _message "No completion for '$service'"
        return 0
    fi

}

_livestreamer () {

    _arguments \
      '(*)'{-h,--help}'[Show this help message and exit]' \
      '(*)'{-V,--version}'[show version number and exit]' \
      '(*)'{-u,--plugins}'[print all currently installed plugins]' \
      '(-Q --quiet -l --loglevel)'{-l,--loglevel}'[set level of log output]:level:( none error warning info debug )' \
      '(-Q --quiet)'{-Q,--quiet}'[alias for --loglevel none]' \
      '(-j --json)'{-j,--json}'[output JSON instead of the normal text output]' \
      '(-p --player)'{-p,--player}'[set player command-line to start]:player command' \
      '(-q --quiet-player)'{-q,--quiet-player}'[hide player console output]' \
      '(-v --verbose-player)'{-v,--verbose-player}'[show all player console output]' \
      '(-n --fifo -o --output -O --stdout)'{-n,--fifo}'[play file using a named pipe instead of stdin]:fifo file:_files -g "*(@)"' \
      '(-n --fifo -o --output -O --stdout)'{-o,--output}'[write stream to file instead of playing it]:output file:_files' \
      '(-f --force)'{-f,--force}'[overwrite existing files]' \
      '(-n --fifo -o --output -O --stdout)'{-O,--stdout}'[write to stdout instead of playing]' \
      '(-c --cmdline)'{-c,--cmdline}'[print command-line used internally to play stream]' \
      '(-e --errorlog)'{-e,--errorlog}'[log errors to a temporary file]' \
      '(-r --rtmpdump)'{-r,--rtmpdump}'[specify location of rtmpdump executable]:rtmpdump executable:_files -g "*(x)"' \
      --rtmpdump-proxy'[set a proxy (SOCKS) that rtmpdump will use]:proxy host\:port' \
      --hds-live-edge'[specify offset from edge of stream for hds]:time offset (default 10s)' \
      --hds-fragment-buffer'[specify maximum amount of fragments to buffer]:fragments (default 10)' \
      --ringbuffer-size'[specify maximum size for the ringbuffer]:size (default 32768)' \
      --plugin-dirs'[set plugin directory (separate using ; )]:plugin directory:_files -/' \
      '(--stream-types --stream-priority)'{--stream-types,--stream-priority}'[specify list of accepted stream types]:types' \
      --stream-sorting-excludes'[fine tune best/worst synonyms]:filter' \
      --jtv-cookie'[specify JustinTV cookie]:cookie' \
      --gomtv-cookie'[specify GOMTV cookie]:cookie' \
      --gomtv-username'[specify GOMTV username]:username' \
      --gomtv-password'[specify GOMTV password]:password' \
      1:url:_livestreamer_urls \
      2:stream \
      && ret=0

}

_livestreamer "$@"
