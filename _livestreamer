#compdef livestreamer

# wrongparse twitch's json api
# returns stream_names and stream_descrs (non-associative) arrays
# see http://www.twitch.tv/docs/api/team.html
_twitch_team_live () {

    local viewmin maxstreams format
    zstyle -s ":completion:${curcontext}:twitch:teams:$1" viewmin viewmin || viewmin=50
    zstyle -s ":completion:${curcontext}:twitch:teams:$1" maxstreams maxstreams || maxstreams=20
    zstyle -s ":completion:${curcontext}:twitch:teams:$1" format format || format="%-5c %15d %t"

    # associative arrays are not ordered, so we use regular ones with synced indices here.
    stream_names=( )
    stream_descrs=( )
    typeset -a att

    # wow, this PYTHONIOENCODING shit took me way too long to figure out oO
    curl -s -X GET "http://api.twitch.tv/api/team/$1/live_channels.json" \
        | PYTHONIOENCODING=UTF-8 python -c '
import sys, json
data = json.loads(sys.stdin.read())
for s in data["channels"]:
    print "\0".join([
        s["channel"]["name"],
        s["channel"]["display_name"],
        str(s["channel"]["current_viewers"]),
        s["channel"]["meta_game"],
        s["channel"]["title"],
    ])
' 2>/dev/null \
        | while IFS=$'\0' read -r -A att; do

            # strip any non-printable characters
            att=( "${(@)att//[^[:print:]]/}" )

            # skip if it's not the right number of attributes for some reason
            (( $#att == 5 )) || continue

            # break if we are below the desired min viewer count
            (( $att[3] >= viewmin )) || break
            # check if we are at the maximum
            (( $#stream_names < maxstreams )) || break

            # ok, add with description
            stream_names+=( $att[1] )
            zformat -f REPLY $format \
                c:$att[3] \
                d:$att[2] \
                m:$att[4] \
                n:$att[1] \
                t:$att[5]
            stream_descrs+=( $REPLY )
    done

    _wanted -V team_$1 expl "Team '$1'" \
        compadd -l -d stream_descrs -a stream_names

}

_twitch_team_streams () {

    (( $+commands[curl] && $+commands[python] )) || return 1

    local ret=1
    local -a teams stream_names stream_descrs

    # look up which teams to complete (srl for default because it's my usecase. you just configure it. :P)
    zstyle -a ":completion:${curcontext}:twitch" teams teams || teams=( srl )
    for team in $teams; do
        _twitch_team_live $team && ret=0
    done

    return $ret

}

_twitch_subscribed () {

    (( $+commands[curl] && $+commands[python] )) || return 1

    local token
    # need this for subscribed channel completion
    zstyle -a ":completion:${curcontext}:twitch:subs" oauth-token token || return 1

    local viewmin maxstreams format
    zstyle -s ":completion:${curcontext}:twitch:subs" viewmin viewmin || viewmin=0
    zstyle -s ":completion:${curcontext}:twitch:subs" maxstreams maxstreams || maxstreams=20
    zstyle -s ":completion:${curcontext}:twitch:subs" format format || format="%-5c %15d %t"

    local -a stream_names stream_descrs att

    curl -s -H 'Accept: application/vnd.twitchtv.v2+json' -H "Authorization: OAuth $token" -X GET https://api.twitch.tv/kraken/streams/followed \
        | PYTHONIOENCODING=UTF-8 python -c '
import sys, json
data = json.loads(sys.stdin.read())
for s in data["streams"]:
    print "\0".join([
        s["channel"]["name"],
        s["channel"]["display_name"],
        str(s["viewers"]),
        s["channel"]["game"],
        s["channel"]["status"]
    ])
' 2>/dev/null \
        | while IFS=$'\0' read -r -A att; do

            # strip any non-printable characters
            att=( "${(@)att//[^[:print:]]/}" )

            # skip if it's not the right number of attributes for some reason
            (( $#att == 5 )) || continue

            # break if we are below the desired min viewer count
            (( $att[3] >= viewmin )) || break
            # check if we are at the maximum
            (( $#stream_names < maxstreams )) || break

            # ok, add with description
            stream_names+=( $att[1] )
            zformat -f REPLY $format \
                c:$att[3] \
                d:$att[2] \
                m:$att[4] \
                n:$att[1] \
                t:$att[5]
            stream_descrs+=( $REPLY )
    done

    _message -e subscribed "No live subscribed streams"
    _wanted -V subscribed expl "Subscribed Streams" \
        compadd -l -d stream_descrs -a stream_names

}

_livestreamer_twitch.tv () {

    _alternative \
        'subscribed:Subscribed Streams:_twitch_subscribed' \
        'teams:Team Streams:_twitch_team_streams'

}

_livestreamer_urls () {

    # ALRIGHT THIS IS IT
    local -a expl
    local ret=1 service

    # complete protocol
    if ! compset -P '(#b)([-+.a-z0-9]#)://'; then
        compstate[to_end]=''
        _wanted prefixes expl 'url prefix' \
            compadd -S '' "$expl[@]" 'http://' && return 0
        return 1
    fi
    # we could capture the scheme here, but we don't actually care
    # scheme="$match[1]"

    typeset -a plugins
    plugins=( twitch.tv )

    if ! compset -P '(#b)([-+.a-zA-Z0-9]#)/'; then
        _wanted prefixes expl 'streaming service' \
            compadd -S '/' "$expl[@]" -a plugins && return 0
        return 1
    fi

    # capture the service
    service=$match[1]

    if (( $+functions[_livestreamer_$service] )); then
        _livestreamer_$service
    else
        _message "No completion for '$service'"
        return 0
    fi

}

_livestreamer () {

    local curcontext="${curcontext}"

    _arguments -C \
      '(*)'{-h,--help}'[Show this help message and exit]' \
      '(*)'{-V,--version}'[show version number and exit]' \
      '(*)'{-u,--plugins}'[print all currently installed plugins]' \
      '(-Q --quiet -l --loglevel)'{-l,--loglevel}'[set level of log output]:level:( none error warning info debug )' \
      '(-Q --quiet)'{-Q,--quiet}'[alias for --loglevel none]' \
      '(-j --json)'{-j,--json}'[output JSON instead of the normal text output]' \
      '(-p --player)'{-p,--player}'[set player command-line to start]:player command' \
      '(-q --quiet-player)'{-q,--quiet-player}'[hide player console output]' \
      '(-v --verbose-player)'{-v,--verbose-player}'[show all player console output]' \
      '(-n --fifo -o --output -O --stdout)'{-n,--fifo}'[play file using a named pipe instead of stdin]:fifo file:_files -g "*(@)"' \
      '(-n --fifo -o --output -O --stdout)'{-o,--output}'[write stream to file instead of playing it]:output file:_files' \
      '(-f --force)'{-f,--force}'[overwrite existing files]' \
      '(-n --fifo -o --output -O --stdout)'{-O,--stdout}'[write to stdout instead of playing]' \
      '(-c --cmdline)'{-c,--cmdline}'[print command-line used internally to play stream]' \
      '(-e --errorlog)'{-e,--errorlog}'[log errors to a temporary file]' \
      '(-r --rtmpdump)'{-r,--rtmpdump}'[specify location of rtmpdump executable]:rtmpdump executable:_files -g "*(x)"' \
      --rtmpdump-proxy'[set a proxy (SOCKS) that rtmpdump will use]:proxy host\:port' \
      --hds-live-edge'[specify offset from edge of stream for hds]:time offset (default 10s)' \
      --hds-fragment-buffer'[specify maximum amount of fragments to buffer]:fragments (default 10)' \
      --ringbuffer-size'[specify maximum size for the ringbuffer]:size (default 32768)' \
      --plugin-dirs'[set plugin directory (separate using ; )]:plugin directory:_files -/' \
      '(--stream-types --stream-priority)'{--stream-types,--stream-priority}'[specify list of accepted stream types]:types' \
      --stream-sorting-excludes'[fine tune best/worst synonyms]:filter' \
      --jtv-cookie'[specify JustinTV cookie]:cookie' \
      --gomtv-cookie'[specify GOMTV cookie]:cookie' \
      --gomtv-username'[specify GOMTV username]:username' \
      --gomtv-password'[specify GOMTV password]:password' \
      1:url:_livestreamer_urls \
      '2:stream quality:( best worst )' \
      && ret=0

}

_livestreamer "$@"
